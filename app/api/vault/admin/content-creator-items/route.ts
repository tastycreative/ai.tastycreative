import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { prisma } from "@/lib/database";

// Helper to extract generatedByClerkId from metadata
function getGeneratorClerkId(metadata: unknown): string | null {
  if (metadata && typeof metadata === 'object' && 'generatedByClerkId' in metadata) {
    return (metadata as { generatedByClerkId?: string }).generatedByClerkId || null;
  }
  return null;
}

// GET /api/vault/admin/content-creator-items - Get all vault items from Content Creator users (Admin only)
// This now shows content based on who GENERATED it (metadata.generatedByClerkId), not who owns the folder
export async function GET(request: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Verify that the requesting user is an admin (OWNER, ADMIN, or MANAGER)
    const requestingUser = await prisma.user.findUnique({
      where: { clerkId: userId },
      select: { 
        id: true,
        teamMemberships: {
          select: {
            role: true
          }
        }
      }
    });

    if (!requestingUser || requestingUser.teamMemberships.length === 0) {
      return NextResponse.json({ error: 'Forbidden - Admin access required' }, { status: 403 });
    }

    // Check if user has OWNER, ADMIN, or MANAGER role in any team
    const hasAdminRole = requestingUser.teamMemberships.some(
      membership => membership.role === 'OWNER' || membership.role === 'ADMIN' || membership.role === 'MANAGER'
    );

    if (!hasAdminRole) {
      return NextResponse.json({ error: 'Forbidden - Admin access required' }, { status: 403 });
    }

    const { searchParams } = new URL(request.url);
    const contentCreatorId = searchParams.get("contentCreatorId");

    // Get all team members with CREATOR role
    const creatorMembers = await prisma.teamMember.findMany({
      where: {
        role: 'CREATOR'
      },
      include: {
        user: {
          select: {
            id: true,
            clerkId: true,
            firstName: true,
            lastName: true,
            email: true,
          }
        }
      },
      orderBy: {
        user: {
          firstName: 'asc'
        }
      }
    });

    // Transform to the format expected by the rest of the code
    const contentCreators = creatorMembers.map(member => member.user);
    const contentCreatorClerkIds = contentCreators.map(cc => cc.clerkId);

    // If a specific content creator is selected, get items GENERATED by them
    // This includes items saved in any folder (including shared folders owned by others)
    if (contentCreatorId) {
      const contentCreator = contentCreators.find(cc => cc.id === contentCreatorId || cc.clerkId === contentCreatorId);
      
      if (!contentCreator) {
        return NextResponse.json({ error: "Content creator not found" }, { status: 404 });
      }

      // Fetch ALL vault items and filter by generatedByClerkId in metadata
      // This is necessary because we need to find items where metadata.generatedByClerkId matches
      // We also include items where clerkId matches but generatedByClerkId is not set (legacy items)
      const allVaultItems = await prisma.vaultItem.findMany({
        include: {
          folder: {
            select: {
              id: true,
              name: true,
              isDefault: true,
              clerkId: true, // Include folder owner for context
            }
          },
        },
        orderBy: {
          createdAt: "desc",
        },
      });

      // Filter items that were GENERATED by this content creator
      const items = allVaultItems.filter(item => {
        const generatorClerkId = getGeneratorClerkId(item.metadata);
        // Item was generated by this creator if:
        // 1. metadata.generatedByClerkId matches, OR
        // 2. No generatedByClerkId is set AND clerkId matches (legacy items)
        if (generatorClerkId) {
          return generatorClerkId === contentCreator.clerkId;
        }
        return item.clerkId === contentCreator.clerkId;
      });

      // Fetch all profiles to map profile names
      const allProfiles = await prisma.instagramProfile.findMany({
        select: { id: true, name: true, instagramUsername: true, clerkId: true }
      });
      const profileMap = new Map(allProfiles.map(p => [p.id, p]));

      // Fetch all folders to provide folder context (may include folders from other users)
      const allFolders = await prisma.vaultFolder.findMany({
        select: {
          id: true,
          name: true,
          profileId: true,
          isDefault: true,
          clerkId: true,
        },
        orderBy: [
          { isDefault: 'desc' },
          { name: 'asc' }
        ]
      });

      // Get unique folder IDs from the filtered items
      const itemFolderIds = new Set(items.map(item => item.folderId));
      
      // Filter folders that contain items generated by this creator
      const relevantFolders = allFolders.filter(folder => itemFolderIds.has(folder.id));
      
      // Count items per folder for this creator
      const folderItemCounts = new Map<string, number>();
      items.forEach(item => {
        const count = folderItemCounts.get(item.folderId) || 0;
        folderItemCounts.set(item.folderId, count + 1);
      });

      // Map folders with item count
      const foldersWithCount = relevantFolders.map(folder => ({
        id: folder.id,
        name: folder.name,
        profileId: folder.profileId,
        isDefault: folder.isDefault,
        itemCount: folderItemCounts.get(folder.id) || 0,
        profileName: profileMap.get(folder.profileId)?.name || 'Unknown Profile',
        // Indicate if this folder is owned by someone else
        isSharedFolder: folder.clerkId !== contentCreator.clerkId,
        folderOwnerClerkId: folder.clerkId,
      }));

      // Get profiles relevant to this creator's items
      const itemProfileIds = new Set(items.map(item => item.profileId));
      const profiles = allProfiles.filter(p => itemProfileIds.has(p.id));

      return NextResponse.json({
        contentCreators,
        selectedContentCreator: contentCreator,
        folders: foldersWithCount,
        profiles,
        items: items.map(item => ({
          ...item,
          creatorName: `${contentCreator.firstName || ''} ${contentCreator.lastName || ''}`.trim() || contentCreator.email || 'Unknown',
          creatorId: contentCreator.id,
          profile: profileMap.get(item.profileId) || null,
          // Add context about where the item is saved
          savedInSharedFolder: item.folder?.clerkId !== contentCreator.clerkId,
          folderOwnerClerkId: item.folder?.clerkId,
        })),
      });
    }

    // If no specific content creator, return all items GENERATED by any content creator
    // This includes items in shared folders
    const allVaultItems = await prisma.vaultItem.findMany({
      include: {
        folder: {
          select: {
            id: true,
            name: true,
            isDefault: true,
            clerkId: true,
          }
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    // Filter items that were generated by any content creator
    const itemsGeneratedByCreators = allVaultItems.filter(item => {
      const generatorClerkId = getGeneratorClerkId(item.metadata);
      // If generatedByClerkId is set, use it to determine the creator
      if (generatorClerkId) {
        return contentCreatorClerkIds.includes(generatorClerkId);
      }
      // Fallback: if no generatedByClerkId, use folder owner (clerkId) - legacy items
      return contentCreatorClerkIds.includes(item.clerkId);
    });

    // Fetch all profiles for mapping
    const allProfiles = await prisma.instagramProfile.findMany({
      select: { id: true, name: true, instagramUsername: true }
    });
    const profileMap = new Map(allProfiles.map(p => [p.id, p]));

    // Map items with creator information based on who GENERATED them
    const itemsWithCreatorInfo = itemsGeneratedByCreators.map(item => {
      const generatorClerkId = getGeneratorClerkId(item.metadata);
      // Find the actual creator based on generatedByClerkId or fallback to clerkId
      const creatorClerkId = generatorClerkId || item.clerkId;
      const creator = contentCreators.find(cc => cc.clerkId === creatorClerkId);
      
      return {
        ...item,
        creatorName: creator 
          ? `${creator.firstName || ''} ${creator.lastName || ''}`.trim() || creator.email || 'Unknown'
          : 'Unknown',
        creatorId: creator?.id || null,
        profile: profileMap.get(item.profileId) || null,
        // Add context about where the item is saved
        savedInSharedFolder: item.folder?.clerkId !== creatorClerkId,
        folderOwnerClerkId: item.folder?.clerkId,
      };
    });

    return NextResponse.json({
      contentCreators,
      selectedContentCreator: null,
      items: itemsWithCreatorInfo,
    });
  } catch (error) {
    console.error("Error fetching content creator vault items:", error);
    return NextResponse.json(
      { error: "Failed to fetch content creator items" },
      { status: 500 }
    );
  }
}
