generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String            @id @default(cuid())
  clerkId                String            @unique
  email                  String?
  username               String?
  firstName              String?
  lastName               String?
  imageUrl               String?
  coverImageUrl          String?
  createdAt              DateTime          @default(now())
  updatedAt              DateTime          @updatedAt
  role                   UserRole          @default(USER)
  instagramAccessToken   String?
  instagramAccountId     String?
  instagramTokenExpiry   DateTime?
  images                 GeneratedImage[]
  videos                 GeneratedVideo[]
  jobs                   GenerationJob[]
  influencers            InfluencerLoRA[]
  productionEntries      ProductionEntry[]
  trainingImages         TrainingImage[]
  trainingJobs           TrainingJob[]
  instagramPosts         InstagramPost[]
  notifications          Notification[]
  fluxKontextConversations FluxKontextConversation[]
  instagramProfiles      InstagramProfile[]
  sentFriendRequests     Friendship[] @relation("SentFriendRequests")
  receivedFriendRequests Friendship[] @relation("ReceivedFriendRequests")
  feedPosts              FeedPost[]
  feedPostLikes          FeedPostLike[]
  feedPostComments       FeedPostComment[]
  feedPostCommentLikes   FeedPostCommentLike[]
  feedPostBookmarks      FeedPostBookmark[]

  @@map("users")
}

model InfluencerLoRA {
  id                 String       @id @default(cuid())
  clerkId            String
  name               String
  displayName        String
  fileName           String       @unique
  originalFileName   String
  fileSize           Int
  uploadedAt         DateTime     @default(now())
  updatedAt          DateTime     @updatedAt
  description        String?
  thumbnailUrl       String?
  cloudinaryUrl      String?
  cloudinaryPublicId String?
  isActive           Boolean      @default(true)
  usageCount         Int          @default(0)
  comfyUIPath        String?
  syncStatus         SyncStatus   @default(PENDING)
  lastUsedAt         DateTime?
  trainingJobId      String?
  user               User         @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)
  trainingJob        TrainingJob? @relation(fields: [trainingJobId], references: [id])
  shares             LoRAShare[]  // LoRA shares with other users

  @@index([clerkId])
  @@index([fileName])
  @@index([isActive])
  @@index([trainingJobId])
  @@map("influencer_loras")
}

model GenerationJob {
  id                     String           @id @default(cuid())
  clerkId                String
  status                 JobStatus        @default(PENDING)
  progress               Int?             @default(0)
  resultUrls             String[]         @default([])
  error                  String?
  type                   GenerationType   @default(TEXT_TO_IMAGE)
  createdAt              DateTime         @default(now())
  updatedAt              DateTime         @updatedAt
  lastChecked            DateTime?
  comfyUIPromptId        String?
  params                 Json?
  stage                  String?
  message                String?
  elapsedTime            Int?
  estimatedTimeRemaining Int?
  images                 GeneratedImage[]
  videos                 GeneratedVideo[]
  user                   User             @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)

  @@index([clerkId])
  @@index([status])
  @@index([type])
  @@index([createdAt])
  @@index([clerkId, createdAt])
  @@index([clerkId, status])
  @@index([clerkId, type])
  @@map("generation_jobs")
}

model GeneratedImage {
  id                String        @id @default(cuid())
  clerkId           String
  jobId             String
  filename          String
  subfolder         String        @default("")
  type              String        @default("output")
  fileSize          Int?
  width             Int?
  height            Int?
  format            String?
  data              Bytes?
  metadata          Json?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  networkVolumePath String?
  s3Key             String?
  awsS3Key          String?
  awsS3Url          String?
  googleDriveFileId String?       // Google Drive file ID for sync tracking
  googleDriveFolderName String?   // Folder name where it was uploaded
  googleDriveUploadedAt DateTime? // When it was uploaded to Google Drive
  loraModels        String[]      @default([]) // Array of LoRA model filenames used in generation
  user              User          @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)
  job               GenerationJob @relation(fields: [jobId], references: [id], onDelete: Cascade)
  productionLinks   ProductionEntryImage[]

  @@unique([jobId, filename, subfolder, type])
  @@index([clerkId])
  @@index([jobId])
  @@index([clerkId, createdAt])
  @@index([format])
  @@index([filename])
  @@index([networkVolumePath])
  @@index([s3Key])
  @@index([awsS3Key])
  @@index([googleDriveFileId])
  @@index([loraModels]) // Index for efficient LoRA-based queries
  @@map("generated_images")
}

model GeneratedVideo {
  id                String        @id @default(cuid())
  clerkId           String
  jobId             String
  filename          String
  subfolder         String        @default("")
  type              String        @default("output")
  fileSize          Int?
  width             Int?
  height            Int?
  duration          Float?
  fps               Float?
  format            String?
  data              Bytes?
  metadata          Json?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  networkVolumePath String?
  s3Key             String?
  awsS3Key          String?
  awsS3Url          String?
  googleDriveFileId String?       // Google Drive file ID for sync tracking
  googleDriveFolderName String?   // Folder name where it was uploaded
  googleDriveUploadedAt DateTime? // When it was uploaded to Google Drive
  user              User          @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)
  job               GenerationJob @relation(fields: [jobId], references: [id], onDelete: Cascade)
  productionLinks   ProductionEntryVideo[]

  @@unique([jobId, filename, subfolder, type])
  @@index([clerkId])
  @@index([jobId])
  @@index([clerkId, createdAt])
  @@index([format])
  @@index([filename])
  @@index([duration])
  @@index([fileSize])
  @@index([s3Key])
  @@index([googleDriveFileId])
  @@map("generated_videos")
}

model TrainingJob {
  id             String           @id @default(cuid())
  clerkId        String
  name           String
  description    String?
  status         TrainingStatus   @default(PENDING)
  progress       Int?             @default(0)
  currentStep    Int?             @default(0)
  totalSteps     Int?
  runpodJobId    String?
  runpodPodId    String?
  trainingConfig Json
  datasetConfig  Json
  modelConfig    Json
  sampleConfig   Json
  error          String?
  loss           Float?
  learningRate   Float?
  eta            String?
  sampleUrls     String[]         @default([])
  checkpointUrls String[]         @default([])
  finalModelUrl  String?
  logUrl         String?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  startedAt      DateTime?
  completedAt    DateTime?
  resultingLoRAs InfluencerLoRA[]
  trainingImages TrainingImage[]
  user           User             @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)

  @@index([clerkId])
  @@index([status])
  @@index([clerkId, status])
  @@index([createdAt])
  @@index([runpodJobId])
  @@map("training_jobs")
}

model TrainingImage {
  id            String      @id @default(cuid())
  clerkId       String
  trainingJobId String
  filename      String
  caption       String?
  fileSize      Int?
  width         Int?
  height        Int?
  format        String?
  storageUrl    String
  localPath     String?
  uploadedAt    DateTime    @default(now())
  user          User        @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)
  trainingJob   TrainingJob @relation(fields: [trainingJobId], references: [id], onDelete: Cascade)

  @@unique([trainingJobId, filename])
  @@index([trainingJobId])
  @@index([clerkId])
  @@map("training_images")
}

model ProductionEntry {
  id              String           @id @default(cuid())
  clerkId         String
  deadline        DateTime
  assignee        String
  influencer      String
  instagramSource String
  loraModel       String
  status          ProductionStatus @default(PENDING)
  imagesTarget    Int              @default(0)
  imagesGenerated Int              @default(0)
  videosTarget    Int              @default(0)
  videosGenerated Int              @default(0)
  notes           String?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  user            User             @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)
  linkedImages    ProductionEntryImage[]
  linkedVideos    ProductionEntryVideo[]

  @@index([clerkId])
  @@index([status])
  @@index([deadline])
  @@index([assignee])
  @@map("production_entries")
}

model InstagramPost {
  id              String              @id @default(cuid())
  clerkId         String
  profileId       String?             // Link to InstagramProfile
  driveFileId     String?             // Made optional for S3 migration
  driveFileUrl    String?             // Made optional for S3 migration
  awsS3Key        String?             // S3 object key
  awsS3Url        String?             // Direct S3 URL
  fileName        String
  caption         String              @default("")
  scheduledDate   DateTime?
  status          InstagramPostStatus @default(DRAFT)
  postType        PostType            @default(POST)
  folder          String              // Current folder (status-based)
  originalFolder  String?             // Original folder where image came from (IG Posts, IG Reels, Misc)
  order           Int                 @default(0)
  mimeType        String?
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  rejectedAt      DateTime?
  rejectedBy      String?
  rejectionReason String?
  // Published post tracking
  instagramUrl    String?             // URL to the published Instagram post
  publishedAt     DateTime?           // When the post was actually published
  likesCount      Int?                // Manual entry of likes count
  commentsCount   Int?                // Manual entry of comments count
  lastMetricsUpdate DateTime?         // Last time metrics were updated
  user            User                @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)
  profile         InstagramProfile?   @relation(fields: [profileId], references: [id], onDelete: SetNull)

  @@index([clerkId])
  @@index([profileId])
  @@index([clerkId, profileId])
  @@index([clerkId, order])
  @@index([status])
  @@index([scheduledDate])
  @@index([driveFileId])
  @@index([awsS3Key])
  @@map("instagram_posts")
}

enum SyncStatus {
  PENDING
  SYNCED
  MISSING
  ERROR
}

enum JobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum TrainingStatus {
  PENDING
  QUEUED
  INITIALIZING
  PROCESSING
  SAMPLING
  SAVING
  COMPLETED
  FAILED
  CANCELLED
  TIMEOUT
}

enum GenerationType {
  TEXT_TO_IMAGE
  IMAGE_TO_VIDEO
  IMAGE_TO_IMAGE
  TEXT_TO_VIDEO
  VIDEO_TO_VIDEO
  SKIN_ENHANCEMENT
  IMAGE_TO_IMAGE_SKIN_ENHANCEMENT
  FACE_SWAP
  VIDEO_FPS_BOOST
  FLUX_KONTEXT
}

enum UserRole {
  USER
  MANAGER
  ADMIN
  CONTENT_CREATOR
}

enum ProductionStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
}

enum InstagramPostStatus {
  DRAFT
  REVIEW
  APPROVED
  SCHEDULED
  PENDING      // Reminder sent, waiting for user to post manually
  PUBLISHED
}

model Notification {
  id          String             @id @default(cuid())
  userId      String
  user        User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  type        NotificationType
  title       String
  message     String
  link        String?            // Optional link to related content
  metadata    Json?              // Additional data (postId, etc.)
  read        Boolean            @default(false)
  readAt      DateTime?
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt

  @@index([userId, read])
  @@index([createdAt])
  @@map("notifications")
}

enum NotificationType {
  POST_REMINDER      // Instagram post is ready to be published
  POST_APPROVED      // Post has been approved
  POST_REJECTED      // Post has been rejected
  SYSTEM             // System notifications
}

enum PostType {
  POST
  REEL
  STORY
}

// Junction table for linking images to production entries
model ProductionEntryImage {
  id                String           @id @default(cuid())
  productionEntryId String
  imageId           String
  createdAt         DateTime         @default(now())
  productionEntry   ProductionEntry  @relation(fields: [productionEntryId], references: [id], onDelete: Cascade)
  image             GeneratedImage   @relation(fields: [imageId], references: [id], onDelete: Cascade)

  @@unique([productionEntryId, imageId])
  @@index([productionEntryId])
  @@index([imageId])
  @@map("production_entry_images")
}

// Junction table for linking videos to production entries
model ProductionEntryVideo {
  id                String           @id @default(cuid())
  productionEntryId String
  videoId           String
  createdAt         DateTime         @default(now())
  productionEntry   ProductionEntry  @relation(fields: [productionEntryId], references: [id], onDelete: Cascade)
  video             GeneratedVideo   @relation(fields: [videoId], references: [id], onDelete: Cascade)

  @@unique([productionEntryId, videoId])
  @@index([productionEntryId])
  @@index([videoId])
  @@map("production_entry_videos")
}

// Multipart upload session storage for large file uploads
model MultipartUploadSession {
  id               String   @id @default(cuid())
  sessionId        String   @unique
  clerkId          String
  uploadId         String
  s3Key            String
  uniqueFileName   String
  totalParts       Int
  uploadedParts    Json     @default("[]") // Array of {ETag: string, PartNumber: number}
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  expiresAt        DateTime // Auto-cleanup old sessions

  @@index([sessionId])
  @@index([clerkId])
  @@index([expiresAt])
  @@map("multipart_upload_sessions")
}

// Flux Kontext conversation history
model FluxKontextConversation {
  id        String                    @id @default(cuid())
  clerkId   String
  title     String?                   // Optional title for the conversation
  createdAt DateTime                  @default(now())
  updatedAt DateTime                  @updatedAt
  user      User                      @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)
  messages  FluxKontextMessage[]

  @@index([clerkId])
  @@index([clerkId, updatedAt])
  @@map("flux_kontext_conversations")
}

model FluxKontextMessage {
  id             String                  @id @default(cuid())
  conversationId String
  role           MessageRole
  content        String                  @db.Text
  imageData      String?                 @db.Text // Base64 image data if present
  createdAt      DateTime                @default(now())
  conversation   FluxKontextConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([conversationId, createdAt])
  @@map("flux_kontext_messages")
}

model FolderShare {
  id            String   @id @default(cuid())
  folderPrefix  String   // S3 folder prefix (e.g., "outputs/user123/nov-2/")
  ownerClerkId  String   // Owner of the folder
  sharedWithClerkId String // User it's shared with
  permission    SharePermission @default(VIEW) // View or Edit
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  sharedBy      String?  // Name/email of person who shared (for display)
  note          String?  // Optional note from the person sharing

  @@unique([folderPrefix, sharedWithClerkId])
  @@index([ownerClerkId])
  @@index([sharedWithClerkId])
  @@index([folderPrefix])
  @@map("folder_shares")
}

model LoRAShare {
  id            String   @id @default(cuid())
  loraId        String   // ID of the InfluencerLoRA being shared
  ownerClerkId  String   // Owner of the LoRA
  sharedWithClerkId String // User it's shared with
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  sharedBy      String?  // Name/email of person who shared (for display)
  note          String?  // Optional note from the person sharing
  lora          InfluencerLoRA @relation(fields: [loraId], references: [id], onDelete: Cascade)

  @@unique([loraId, sharedWithClerkId])
  @@index([ownerClerkId])
  @@index([sharedWithClerkId])
  @@index([loraId])
  @@map("lora_shares")
}

enum SharePermission {
  VIEW   // Can only view content
  EDIT   // Can view and upload to folder
}

enum MessageRole {
  USER
  ASSISTANT
  SYSTEM
}

model InstagramProfile {
  id                   String            @id @default(cuid())
  clerkId              String
  name                 String            // Profile name (e.g., "Personal Brand", "Business Account")
  description          String?           // Optional description
  instagramUsername    String?           // Instagram handle (optional)
  instagramAccountId   String?           // Instagram account ID for API
  instagramAccessToken String?           // Access token for this specific profile
  instagramTokenExpiry DateTime?         // Token expiry
  isDefault            Boolean           @default(false) // Mark one profile as default
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt
  user                 User              @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)
  posts                InstagramPost[]

  @@index([clerkId])
  @@index([clerkId, isDefault])
  @@map("instagram_profiles")
}

model Friendship {
  id          String           @id @default(cuid())
  senderId    String           // User who sent the request
  receiverId  String           // User who received the request
  status      FriendshipStatus @default(PENDING)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  sender      User             @relation("SentFriendRequests", fields: [senderId], references: [id], onDelete: Cascade)
  receiver    User             @relation("ReceivedFriendRequests", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@index([senderId])
  @@index([receiverId])
  @@index([senderId, status])
  @@index([receiverId, status])
  @@map("friendships")
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  REJECTED
  BLOCKED
}

model FeedPost {
  id        String              @id @default(cuid())
  userId    String
  imageUrls String[]            // Array of S3 or storage URLs for post images/videos
  mediaType String              @default("image") // 'image' or 'video'
  caption   String              @db.Text
  createdAt DateTime            @default(now())
  updatedAt DateTime            @updatedAt
  user      User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  likes     FeedPostLike[]
  comments  FeedPostComment[]
  bookmarks FeedPostBookmark[]

  @@index([userId])
  @@index([createdAt])
  @@index([userId, createdAt])
  @@map("feed_posts")
}

model FeedPostLike {
  id        String   @id @default(cuid())
  postId    String
  userId    String
  createdAt DateTime @default(now())
  post      FeedPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@index([postId])
  @@index([userId])
  @@map("feed_post_likes")
}

model FeedPostComment {
  id              String                  @id @default(cuid())
  postId          String
  userId          String
  content         String                  @db.Text
  parentCommentId String?                 // For nested replies
  createdAt       DateTime                @default(now())
  updatedAt       DateTime                @updatedAt
  post            FeedPost                @relation(fields: [postId], references: [id], onDelete: Cascade)
  user            User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  likes           FeedPostCommentLike[]
  parentComment   FeedPostComment?        @relation("CommentReplies", fields: [parentCommentId], references: [id], onDelete: Cascade)
  replies         FeedPostComment[]       @relation("CommentReplies")

  @@index([postId])
  @@index([userId])
  @@index([postId, createdAt])
  @@index([parentCommentId])
  @@map("feed_post_comments")
}

model FeedPostCommentLike {
  id        String          @id @default(cuid())
  commentId String
  userId    String
  createdAt DateTime        @default(now())
  comment   FeedPostComment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user      User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([commentId, userId])
  @@index([commentId])
  @@index([userId])
  @@map("feed_post_comment_likes")
}

model FeedPostBookmark {
  id        String   @id @default(cuid())
  postId    String
  userId    String
  createdAt DateTime @default(now())
  post      FeedPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@index([postId])
  @@index([userId])
  @@map("feed_post_bookmarks")
}

model MarketplaceModel {
  id          String              @id @default(cuid())
  name        String
  price       Float
  status      MarketplaceStatus   @default(AVAILABLE)
  imageUrl    String
  category    String              @default("Premium")
  gallery     String[]            @default([])
  description String              @db.Text
  included    String[]            @default([])
  usedFor     String[]            @default([])
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  @@index([status])
  @@index([createdAt])
  @@map("marketplace_models")
}

enum MarketplaceStatus {
  AVAILABLE
  SOLD
  RESERVED
}
