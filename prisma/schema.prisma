generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String            @id @default(cuid())
  clerkId                String            @unique
  email                  String?
  firstName              String?
  lastName               String?
  imageUrl               String?
  createdAt              DateTime          @default(now())
  updatedAt              DateTime          @updatedAt
  role                   UserRole          @default(USER)
  instagramAccessToken   String?
  instagramAccountId     String?
  instagramTokenExpiry   DateTime?
  images                 GeneratedImage[]
  videos                 GeneratedVideo[]
  jobs                   GenerationJob[]
  influencers            InfluencerLoRA[]
  productionEntries      ProductionEntry[]
  trainingImages         TrainingImage[]
  trainingJobs           TrainingJob[]
  instagramPosts         InstagramPost[]
  notifications          Notification[]

  @@map("users")
}

model InfluencerLoRA {
  id                 String       @id @default(cuid())
  clerkId            String
  name               String
  displayName        String
  fileName           String       @unique
  originalFileName   String
  fileSize           Int
  uploadedAt         DateTime     @default(now())
  updatedAt          DateTime     @updatedAt
  description        String?
  thumbnailUrl       String?
  cloudinaryUrl      String?
  cloudinaryPublicId String?
  isActive           Boolean      @default(true)
  usageCount         Int          @default(0)
  comfyUIPath        String?
  syncStatus         SyncStatus   @default(PENDING)
  lastUsedAt         DateTime?
  trainingJobId      String?
  user               User         @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)
  trainingJob        TrainingJob? @relation(fields: [trainingJobId], references: [id])

  @@index([clerkId])
  @@index([fileName])
  @@index([isActive])
  @@index([trainingJobId])
  @@map("influencer_loras")
}

model GenerationJob {
  id                     String           @id @default(cuid())
  clerkId                String
  status                 JobStatus        @default(PENDING)
  progress               Int?             @default(0)
  resultUrls             String[]         @default([])
  error                  String?
  type                   GenerationType   @default(TEXT_TO_IMAGE)
  createdAt              DateTime         @default(now())
  updatedAt              DateTime         @updatedAt
  lastChecked            DateTime?
  comfyUIPromptId        String?
  params                 Json?
  stage                  String?
  message                String?
  elapsedTime            Int?
  estimatedTimeRemaining Int?
  images                 GeneratedImage[]
  videos                 GeneratedVideo[]
  user                   User             @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)

  @@index([clerkId])
  @@index([status])
  @@index([type])
  @@index([createdAt])
  @@index([clerkId, createdAt])
  @@index([clerkId, status])
  @@index([clerkId, type])
  @@map("generation_jobs")
}

model GeneratedImage {
  id                String        @id @default(cuid())
  clerkId           String
  jobId             String
  filename          String
  subfolder         String        @default("")
  type              String        @default("output")
  fileSize          Int?
  width             Int?
  height            Int?
  format            String?
  data              Bytes?
  metadata          Json?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  networkVolumePath String?
  s3Key             String?
  awsS3Key          String?
  awsS3Url          String?
  googleDriveFileId String?       // Google Drive file ID for sync tracking
  googleDriveFolderName String?   // Folder name where it was uploaded
  googleDriveUploadedAt DateTime? // When it was uploaded to Google Drive
  user              User          @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)
  job               GenerationJob @relation(fields: [jobId], references: [id], onDelete: Cascade)
  productionLinks   ProductionEntryImage[]

  @@unique([jobId, filename, subfolder, type])
  @@index([clerkId])
  @@index([jobId])
  @@index([clerkId, createdAt])
  @@index([format])
  @@index([filename])
  @@index([networkVolumePath])
  @@index([s3Key])
  @@index([awsS3Key])
  @@index([googleDriveFileId])
  @@map("generated_images")
}

model GeneratedVideo {
  id                String        @id @default(cuid())
  clerkId           String
  jobId             String
  filename          String
  subfolder         String        @default("")
  type              String        @default("output")
  fileSize          Int?
  width             Int?
  height            Int?
  duration          Float?
  fps               Float?
  format            String?
  data              Bytes?
  metadata          Json?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  networkVolumePath String?
  s3Key             String?
  awsS3Key          String?
  awsS3Url          String?
  googleDriveFileId String?       // Google Drive file ID for sync tracking
  googleDriveFolderName String?   // Folder name where it was uploaded
  googleDriveUploadedAt DateTime? // When it was uploaded to Google Drive
  user              User          @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)
  job               GenerationJob @relation(fields: [jobId], references: [id], onDelete: Cascade)
  productionLinks   ProductionEntryVideo[]

  @@unique([jobId, filename, subfolder, type])
  @@index([clerkId])
  @@index([jobId])
  @@index([clerkId, createdAt])
  @@index([format])
  @@index([filename])
  @@index([duration])
  @@index([fileSize])
  @@index([s3Key])
  @@index([googleDriveFileId])
  @@map("generated_videos")
}

model TrainingJob {
  id             String           @id @default(cuid())
  clerkId        String
  name           String
  description    String?
  status         TrainingStatus   @default(PENDING)
  progress       Int?             @default(0)
  currentStep    Int?             @default(0)
  totalSteps     Int?
  runpodJobId    String?
  runpodPodId    String?
  trainingConfig Json
  datasetConfig  Json
  modelConfig    Json
  sampleConfig   Json
  error          String?
  loss           Float?
  learningRate   Float?
  eta            String?
  sampleUrls     String[]         @default([])
  checkpointUrls String[]         @default([])
  finalModelUrl  String?
  logUrl         String?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  startedAt      DateTime?
  completedAt    DateTime?
  resultingLoRAs InfluencerLoRA[]
  trainingImages TrainingImage[]
  user           User             @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)

  @@index([clerkId])
  @@index([status])
  @@index([clerkId, status])
  @@index([createdAt])
  @@index([runpodJobId])
  @@map("training_jobs")
}

model TrainingImage {
  id            String      @id @default(cuid())
  clerkId       String
  trainingJobId String
  filename      String
  caption       String?
  fileSize      Int?
  width         Int?
  height        Int?
  format        String?
  storageUrl    String
  localPath     String?
  uploadedAt    DateTime    @default(now())
  user          User        @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)
  trainingJob   TrainingJob @relation(fields: [trainingJobId], references: [id], onDelete: Cascade)

  @@unique([trainingJobId, filename])
  @@index([trainingJobId])
  @@index([clerkId])
  @@map("training_images")
}

model ProductionEntry {
  id              String           @id @default(cuid())
  clerkId         String
  deadline        DateTime
  assignee        String
  influencer      String
  instagramSource String
  loraModel       String
  status          ProductionStatus @default(PENDING)
  imagesTarget    Int              @default(0)
  imagesGenerated Int              @default(0)
  videosTarget    Int              @default(0)
  videosGenerated Int              @default(0)
  notes           String?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  user            User             @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)
  linkedImages    ProductionEntryImage[]
  linkedVideos    ProductionEntryVideo[]

  @@index([clerkId])
  @@index([status])
  @@index([deadline])
  @@index([assignee])
  @@map("production_entries")
}

model InstagramPost {
  id              String              @id @default(cuid())
  clerkId         String
  driveFileId     String
  driveFileUrl    String
  fileName        String
  caption         String              @default("")
  scheduledDate   DateTime?
  status          InstagramPostStatus @default(DRAFT)
  postType        PostType            @default(POST)
  folder          String
  order           Int                 @default(0)
  mimeType        String?
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  rejectedAt      DateTime?
  rejectedBy      String?
  rejectionReason String?
  // Published post tracking
  instagramUrl    String?             // URL to the published Instagram post
  publishedAt     DateTime?           // When the post was actually published
  likesCount      Int?                // Manual entry of likes count
  commentsCount   Int?                // Manual entry of comments count
  lastMetricsUpdate DateTime?         // Last time metrics were updated
  user            User                @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)

  @@index([clerkId])
  @@index([clerkId, order])
  @@index([status])
  @@index([scheduledDate])
  @@index([driveFileId])
  @@map("instagram_posts")
}

enum SyncStatus {
  PENDING
  SYNCED
  MISSING
  ERROR
}

enum JobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum TrainingStatus {
  PENDING
  QUEUED
  INITIALIZING
  PROCESSING
  SAMPLING
  SAVING
  COMPLETED
  FAILED
  CANCELLED
  TIMEOUT
}

enum GenerationType {
  TEXT_TO_IMAGE
  IMAGE_TO_VIDEO
  IMAGE_TO_IMAGE
  TEXT_TO_VIDEO
  VIDEO_TO_VIDEO
  SKIN_ENHANCEMENT
  FACE_SWAP
  VIDEO_FPS_BOOST
  FLUX_KONTEXT
}

enum UserRole {
  USER
  MANAGER
  ADMIN
  CONTENT_CREATOR
}

enum ProductionStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
}

enum InstagramPostStatus {
  DRAFT
  REVIEW
  APPROVED
  SCHEDULED
  PENDING      // Reminder sent, waiting for user to post manually
  PUBLISHED
}

model Notification {
  id          String             @id @default(cuid())
  userId      String
  user        User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  type        NotificationType
  title       String
  message     String
  link        String?            // Optional link to related content
  metadata    Json?              // Additional data (postId, etc.)
  read        Boolean            @default(false)
  readAt      DateTime?
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt

  @@index([userId, read])
  @@index([createdAt])
  @@map("notifications")
}

enum NotificationType {
  POST_REMINDER      // Instagram post is ready to be published
  POST_APPROVED      // Post has been approved
  POST_REJECTED      // Post has been rejected
  SYSTEM             // System notifications
}

enum PostType {
  POST
  REEL
  STORY
}

// Junction table for linking images to production entries
model ProductionEntryImage {
  id                String           @id @default(cuid())
  productionEntryId String
  imageId           String
  createdAt         DateTime         @default(now())
  productionEntry   ProductionEntry  @relation(fields: [productionEntryId], references: [id], onDelete: Cascade)
  image             GeneratedImage   @relation(fields: [imageId], references: [id], onDelete: Cascade)

  @@unique([productionEntryId, imageId])
  @@index([productionEntryId])
  @@index([imageId])
  @@map("production_entry_images")
}

// Junction table for linking videos to production entries
model ProductionEntryVideo {
  id                String           @id @default(cuid())
  productionEntryId String
  videoId           String
  createdAt         DateTime         @default(now())
  productionEntry   ProductionEntry  @relation(fields: [productionEntryId], references: [id], onDelete: Cascade)
  video             GeneratedVideo   @relation(fields: [videoId], references: [id], onDelete: Cascade)

  @@unique([productionEntryId, videoId])
  @@index([productionEntryId])
  @@index([videoId])
  @@map("production_entry_videos")
}

// Multipart upload session storage for large file uploads
model MultipartUploadSession {
  id               String   @id @default(cuid())
  sessionId        String   @unique
  clerkId          String
  uploadId         String
  s3Key            String
  uniqueFileName   String
  totalParts       Int
  uploadedParts    Json     @default("[]") // Array of {ETag: string, PartNumber: number}
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  expiresAt        DateTime // Auto-cleanup old sessions

  @@index([sessionId])
  @@index([clerkId])
  @@index([expiresAt])
  @@map("multipart_upload_sessions")
}
