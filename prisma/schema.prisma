generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String            @id @default(cuid())
  clerkId                String            @unique
  email                  String?
  username               String?
  firstName              String?
  lastName               String?
  imageUrl               String?
  coverImageUrl          String?
  createdAt              DateTime          @default(now())
  updatedAt              DateTime          @updatedAt
  role                   UserRole          @default(USER)
  instagramAccessToken   String?
  instagramAccountId     String?
  instagramTokenExpiry   DateTime?
  images                 GeneratedImage[]
  videos                 GeneratedVideo[]
  jobs                   GenerationJob[]
  influencers            InfluencerLoRA[]
  productionEntries      ProductionEntry[]
  trainingImages         TrainingImage[]
  trainingJobs           TrainingJob[]
  instagramPosts         InstagramPost[]
  notifications          Notification[]
  fluxKontextConversations FluxKontextConversation[]
  instagramProfiles      InstagramProfile[]
  feedPosts              FeedPost[]
  feedPostLikes          FeedPostLike[]
  feedPostComments       FeedPostComment[]
  feedPostCommentLikes   FeedPostCommentLike[]
  feedPostBookmarks      FeedPostBookmark[]

  @@map("users")
}

model InfluencerLoRA {
  id                 String       @id @default(cuid())
  clerkId            String
  name               String
  displayName        String
  fileName           String       @unique
  originalFileName   String
  fileSize           Int
  uploadedAt         DateTime     @default(now())
  updatedAt          DateTime     @updatedAt
  description        String?
  thumbnailUrl       String?
  cloudinaryUrl      String?
  cloudinaryPublicId String?
  isActive           Boolean      @default(true)
  usageCount         Int          @default(0)
  comfyUIPath        String?
  syncStatus         SyncStatus   @default(PENDING)
  lastUsedAt         DateTime?
  trainingJobId      String?
  user               User         @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)
  trainingJob        TrainingJob? @relation(fields: [trainingJobId], references: [id])
  shares             LoRAShare[]  // LoRA shares with other users

  @@index([clerkId])
  @@index([fileName])
  @@index([isActive])
  @@index([trainingJobId])
  @@map("influencer_loras")
}

model GenerationJob {
  id                     String           @id @default(cuid())
  clerkId                String
  status                 JobStatus        @default(PENDING)
  progress               Int?             @default(0)
  resultUrls             String[]         @default([])
  error                  String?
  type                   GenerationType   @default(TEXT_TO_IMAGE)
  createdAt              DateTime         @default(now())
  updatedAt              DateTime         @updatedAt
  lastChecked            DateTime?
  comfyUIPromptId        String?
  params                 Json?
  stage                  String?
  message                String?
  elapsedTime            Int?
  estimatedTimeRemaining Int?
  images                 GeneratedImage[]
  videos                 GeneratedVideo[]
  user                   User             @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)

  @@index([clerkId])
  @@index([status])
  @@index([type])
  @@index([createdAt])
  @@index([clerkId, createdAt])
  @@index([clerkId, status])
  @@index([clerkId, type])
  @@map("generation_jobs")
}

model GeneratedImage {
  id                String        @id @default(cuid())
  clerkId           String
  jobId             String
  filename          String
  subfolder         String        @default("")
  type              String        @default("output")
  fileSize          Int?
  width             Int?
  height            Int?
  format            String?
  data              Bytes?
  metadata          Json?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  networkVolumePath String?
  s3Key             String?
  awsS3Key          String?
  awsS3Url          String?
  googleDriveFileId String?       // Google Drive file ID for sync tracking
  googleDriveFolderName String?   // Folder name where it was uploaded
  googleDriveUploadedAt DateTime? // When it was uploaded to Google Drive
  loraModels        String[]      @default([]) // Array of LoRA model filenames used in generation
  user              User          @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)
  job               GenerationJob @relation(fields: [jobId], references: [id], onDelete: Cascade)
  productionLinks   ProductionEntryImage[]

  @@unique([jobId, filename, subfolder, type])
  @@index([clerkId])
  @@index([jobId])
  @@index([clerkId, createdAt])
  @@index([format])
  @@index([filename])
  @@index([networkVolumePath])
  @@index([s3Key])
  @@index([awsS3Key])
  @@index([googleDriveFileId])
  @@index([loraModels]) // Index for efficient LoRA-based queries
  @@map("generated_images")
}

model GeneratedVideo {
  id                String        @id @default(cuid())
  clerkId           String
  jobId             String
  filename          String
  subfolder         String        @default("")
  type              String        @default("output")
  fileSize          Int?
  width             Int?
  height            Int?
  duration          Float?
  fps               Float?
  format            String?
  data              Bytes?
  metadata          Json?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  networkVolumePath String?
  s3Key             String?
  awsS3Key          String?
  awsS3Url          String?
  googleDriveFileId String?       // Google Drive file ID for sync tracking
  googleDriveFolderName String?   // Folder name where it was uploaded
  googleDriveUploadedAt DateTime? // When it was uploaded to Google Drive
  user              User          @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)
  job               GenerationJob @relation(fields: [jobId], references: [id], onDelete: Cascade)
  productionLinks   ProductionEntryVideo[]

  @@unique([jobId, filename, subfolder, type])
  @@index([clerkId])
  @@index([jobId])
  @@index([clerkId, createdAt])
  @@index([format])
  @@index([filename])
  @@index([duration])
  @@index([fileSize])
  @@index([s3Key])
  @@index([googleDriveFileId])
  @@map("generated_videos")
}

model TrainingJob {
  id             String           @id @default(cuid())
  clerkId        String
  name           String
  description    String?
  status         TrainingStatus   @default(PENDING)
  progress       Int?             @default(0)
  currentStep    Int?             @default(0)
  totalSteps     Int?
  runpodJobId    String?
  runpodPodId    String?
  trainingConfig Json
  datasetConfig  Json
  modelConfig    Json
  sampleConfig   Json
  error          String?
  loss           Float?
  learningRate   Float?
  eta            String?
  sampleUrls     String[]         @default([])
  checkpointUrls String[]         @default([])
  finalModelUrl  String?
  logUrl         String?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  startedAt      DateTime?
  completedAt    DateTime?
  resultingLoRAs InfluencerLoRA[]
  trainingImages TrainingImage[]
  user           User             @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)

  @@index([clerkId])
  @@index([status])
  @@index([clerkId, status])
  @@index([createdAt])
  @@index([runpodJobId])
  @@map("training_jobs")
}

model TrainingImage {
  id            String      @id @default(cuid())
  clerkId       String
  trainingJobId String
  filename      String
  caption       String?
  fileSize      Int?
  width         Int?
  height        Int?
  format        String?
  storageUrl    String
  localPath     String?
  uploadedAt    DateTime    @default(now())
  user          User        @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)
  trainingJob   TrainingJob @relation(fields: [trainingJobId], references: [id], onDelete: Cascade)

  @@unique([trainingJobId, filename])
  @@index([trainingJobId])
  @@index([clerkId])
  @@map("training_images")
}

model ProductionEntry {
  id              String           @id @default(cuid())
  clerkId         String
  deadline        DateTime
  assignee        String
  influencer      String
  instagramSource String
  loraModel       String
  status          ProductionStatus @default(PENDING)
  imagesTarget    Int              @default(0)
  imagesGenerated Int              @default(0)
  videosTarget    Int              @default(0)
  videosGenerated Int              @default(0)
  notes           String?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  user            User             @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)
  linkedImages    ProductionEntryImage[]
  linkedVideos    ProductionEntryVideo[]

  @@index([clerkId])
  @@index([status])
  @@index([deadline])
  @@index([assignee])
  @@map("production_entries")
}

model InstagramPost {
  id              String              @id @default(cuid())
  clerkId         String
  profileId       String?             // Link to InstagramProfile
  driveFileId     String?             // Made optional for S3 migration
  driveFileUrl    String?             // Made optional for S3 migration
  awsS3Key        String?             // S3 object key
  awsS3Url        String?             // Direct S3 URL
  fileName        String
  caption         String              @default("")
  scheduledDate   DateTime?
  status          InstagramPostStatus @default(DRAFT)
  postType        PostType            @default(POST)
  folder          String              // Current folder (status-based)
  originalFolder  String?             // Original folder where image came from (IG Posts, IG Reels, Misc)
  order           Int                 @default(0)
  mimeType        String?
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  rejectedAt      DateTime?
  rejectedBy      String?
  rejectionReason String?
  // Published post tracking
  instagramUrl    String?             // URL to the published Instagram post
  publishedAt     DateTime?           // When the post was actually published
  likesCount      Int?                // Manual entry of likes count
  commentsCount   Int?                // Manual entry of comments count
  lastMetricsUpdate DateTime?         // Last time metrics were updated
  user            User                @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)
  profile         InstagramProfile?   @relation(fields: [profileId], references: [id], onDelete: SetNull)
  weeklySlots     WeeklyPlanningSlot[] // Slots where this post is assigned
  pipelineItems   ContentPipelineItem[] // Pipeline tracking items linked to this post
  storySlots      StoryPlanningSlot[] @relation("StorySlots") // Story planning slots

  @@index([clerkId])
  @@index([profileId])
  @@index([clerkId, profileId])
  @@index([clerkId, order])
  @@index([status])
  @@index([scheduledDate])
  @@index([driveFileId])
  @@index([awsS3Key])
  @@map("instagram_posts")
}

enum SyncStatus {
  PENDING
  SYNCED
  MISSING
  ERROR
}

enum JobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum TrainingStatus {
  PENDING
  QUEUED
  INITIALIZING
  PROCESSING
  SAMPLING
  SAVING
  COMPLETED
  FAILED
  CANCELLED
  TIMEOUT
}

enum GenerationType {
  TEXT_TO_IMAGE
  IMAGE_TO_VIDEO
  IMAGE_TO_IMAGE
  TEXT_TO_VIDEO
  VIDEO_TO_VIDEO
  SKIN_ENHANCEMENT
  IMAGE_TO_IMAGE_SKIN_ENHANCEMENT
  FACE_SWAP
  VIDEO_FPS_BOOST
  FLUX_KONTEXT
}

enum UserRole {
  USER
  MANAGER
  ADMIN
  CONTENT_CREATOR
}

enum ProductionStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
}

enum InstagramPostStatus {
  DRAFT
  REVIEW
  APPROVED
  SCHEDULED
  PENDING      // Reminder sent, waiting for user to post manually
  PUBLISHED
}

model Notification {
  id          String             @id @default(cuid())
  userId      String
  user        User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  type        NotificationType
  title       String
  message     String
  link        String?            // Optional link to related content
  metadata    Json?              // Additional data (postId, etc.)
  read        Boolean            @default(false)
  readAt      DateTime?
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt

  @@index([userId, read])
  @@index([createdAt])
  @@map("notifications")
}

enum NotificationType {
  POST_REMINDER      // Instagram post is ready to be published
  POST_APPROVED      // Post has been approved
  POST_REJECTED      // Post has been rejected
  SYSTEM             // System notifications
}

enum PostType {
  POST
  REEL
  STORY
}

// Junction table for linking images to production entries
model ProductionEntryImage {
  id                String           @id @default(cuid())
  productionEntryId String
  imageId           String
  createdAt         DateTime         @default(now())
  productionEntry   ProductionEntry  @relation(fields: [productionEntryId], references: [id], onDelete: Cascade)
  image             GeneratedImage   @relation(fields: [imageId], references: [id], onDelete: Cascade)

  @@unique([productionEntryId, imageId])
  @@index([productionEntryId])
  @@index([imageId])
  @@map("production_entry_images")
}

// Junction table for linking videos to production entries
model ProductionEntryVideo {
  id                String           @id @default(cuid())
  productionEntryId String
  videoId           String
  createdAt         DateTime         @default(now())
  productionEntry   ProductionEntry  @relation(fields: [productionEntryId], references: [id], onDelete: Cascade)
  video             GeneratedVideo   @relation(fields: [videoId], references: [id], onDelete: Cascade)

  @@unique([productionEntryId, videoId])
  @@index([productionEntryId])
  @@index([videoId])
  @@map("production_entry_videos")
}

// Multipart upload session storage for large file uploads
model MultipartUploadSession {
  id               String   @id @default(cuid())
  sessionId        String   @unique
  clerkId          String
  uploadId         String
  s3Key            String
  uniqueFileName   String
  totalParts       Int
  uploadedParts    Json     @default("[]") // Array of {ETag: string, PartNumber: number}
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  expiresAt        DateTime // Auto-cleanup old sessions

  @@index([sessionId])
  @@index([clerkId])
  @@index([expiresAt])
  @@map("multipart_upload_sessions")
}

// Flux Kontext conversation history
model FluxKontextConversation {
  id        String                    @id @default(cuid())
  clerkId   String
  title     String?                   // Optional title for the conversation
  createdAt DateTime                  @default(now())
  updatedAt DateTime                  @updatedAt
  user      User                      @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)
  messages  FluxKontextMessage[]

  @@index([clerkId])
  @@index([clerkId, updatedAt])
  @@map("flux_kontext_conversations")
}

model FluxKontextMessage {
  id             String                  @id @default(cuid())
  conversationId String
  role           MessageRole
  content        String                  @db.Text
  imageData      String?                 @db.Text // Base64 image data if present
  createdAt      DateTime                @default(now())
  conversation   FluxKontextConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([conversationId, createdAt])
  @@map("flux_kontext_messages")
}

model FolderShare {
  id            String   @id @default(cuid())
  folderPrefix  String   // S3 folder prefix (e.g., "outputs/user123/nov-2/")
  ownerClerkId  String   // Owner of the folder
  sharedWithClerkId String // User it's shared with
  permission    SharePermission @default(VIEW) // View or Edit
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  sharedBy      String?  // Name/email of person who shared (for display)
  note          String?  // Optional note from the person sharing

  @@unique([folderPrefix, sharedWithClerkId])
  @@index([ownerClerkId])
  @@index([sharedWithClerkId])
  @@index([folderPrefix])
  @@map("folder_shares")
}

model LoRAShare {
  id            String   @id @default(cuid())
  loraId        String   // ID of the InfluencerLoRA being shared
  ownerClerkId  String   // Owner of the LoRA
  sharedWithClerkId String // User it's shared with
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  sharedBy      String?  // Name/email of person who shared (for display)
  note          String?  // Optional note from the person sharing
  lora          InfluencerLoRA @relation(fields: [loraId], references: [id], onDelete: Cascade)

  @@unique([loraId, sharedWithClerkId])
  @@index([ownerClerkId])
  @@index([sharedWithClerkId])
  @@index([loraId])
  @@map("lora_shares")
}

enum SharePermission {
  VIEW   // Can only view content
  EDIT   // Can view and upload to folder
}

enum MessageRole {
  USER
  ASSISTANT
  SYSTEM
}

model InstagramProfile {
  id                   String            @id @default(cuid())
  clerkId              String
  name                 String            // Profile name (e.g., "Personal Brand", "Business Account")
  description          String?           // Optional description
  instagramUsername    String?           // Instagram handle (optional)
  instagramAccountId   String?           // Instagram account ID for API
  instagramAccessToken String?           // Access token for this specific profile
  instagramTokenExpiry DateTime?         // Token expiry
  profileImageUrl      String?           // Profile image URL
  isDefault            Boolean           @default(false) // Mark one profile as default
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt
  user                 User              @relation(fields: [clerkId], references: [clerkId], onDelete: Cascade)
  posts                InstagramPost[]
  feedPosts            FeedPost[]        // Feed posts for this profile
  sentFriendRequests     Friendship[] @relation("SentFriendRequests")
  receivedFriendRequests Friendship[] @relation("ReceivedFriendRequests")
  comments             FeedPostComment[] @relation("ProfileComments") // Comments made by this profile
  postLikes            FeedPostLike[]    @relation("ProfilePostLikes") // Post likes made by this profile
  commentLikes         FeedPostCommentLike[] @relation("ProfileCommentLikes") // Comment likes made by this profile
  bookmarks            FeedPostBookmark[] @relation("ProfileBookmarks") // Bookmarks made by this profile
  captions             Caption[]         // Captions for this profile

  @@index([clerkId])
  @@index([clerkId, isDefault])
  @@map("instagram_profiles")
}

model Friendship {
  id                String           @id @default(cuid())
  senderProfileId   String           // Profile who sent the request
  receiverProfileId String           // Profile who received the request
  status            FriendshipStatus @default(PENDING)
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  senderProfile     InstagramProfile @relation("SentFriendRequests", fields: [senderProfileId], references: [id], onDelete: Cascade)
  receiverProfile   InstagramProfile @relation("ReceivedFriendRequests", fields: [receiverProfileId], references: [id], onDelete: Cascade)

  @@unique([senderProfileId, receiverProfileId])
  @@index([senderProfileId])
  @@index([receiverProfileId])
  @@index([senderProfileId, status])
  @@index([receiverProfileId, status])
  @@map("friendships")
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  REJECTED
  BLOCKED
}

model FeedPost {
  id        String              @id @default(cuid())
  userId    String
  profileId String?             // Instagram profile this post belongs to
  imageUrls String[]            // Array of S3 or storage URLs for post images/videos
  mediaType String              @default("image") // 'image' or 'video'
  caption   String              @db.Text
  createdAt DateTime            @default(now())
  updatedAt DateTime            @updatedAt
  user      User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  profile   InstagramProfile?   @relation(fields: [profileId], references: [id], onDelete: SetNull)
  likes     FeedPostLike[]
  comments  FeedPostComment[]
  bookmarks FeedPostBookmark[]

  @@index([userId])
  @@index([profileId])
  @@index([createdAt])
  @@index([userId, createdAt])
  @@index([profileId, createdAt])
  @@map("feed_posts")
}

model FeedPostLike {
  id        String            @id @default(cuid())
  postId    String
  userId    String
  profileId String            // Which profile made this like
  createdAt DateTime          @default(now())
  post      FeedPost          @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  profile   InstagramProfile  @relation("ProfilePostLikes", fields: [profileId], references: [id], onDelete: Cascade)

  @@unique([postId, profileId])
  @@index([postId])
  @@index([userId])
  @@index([profileId])
  @@map("feed_post_likes")
}

model FeedPostComment {
  id              String                  @id @default(cuid())
  postId          String
  userId          String
  profileId       String?                 // Which profile made this comment
  content         String                  @db.Text
  parentCommentId String?                 // For nested replies
  createdAt       DateTime                @default(now())
  updatedAt       DateTime                @updatedAt
  post            FeedPost                @relation(fields: [postId], references: [id], onDelete: Cascade)
  user            User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  profile         InstagramProfile?       @relation("ProfileComments", fields: [profileId], references: [id], onDelete: SetNull)
  likes           FeedPostCommentLike[]
  parentComment   FeedPostComment?        @relation("CommentReplies", fields: [parentCommentId], references: [id], onDelete: Cascade)
  replies         FeedPostComment[]       @relation("CommentReplies")

  @@index([postId])
  @@index([userId])
  @@index([profileId])
  @@index([postId, createdAt])
  @@index([parentCommentId])
  @@map("feed_post_comments")
}

model FeedPostCommentLike {
  id        String            @id @default(cuid())
  commentId String
  userId    String
  profileId String            // Which profile made this like
  createdAt DateTime          @default(now())
  comment   FeedPostComment   @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user      User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  profile   InstagramProfile  @relation("ProfileCommentLikes", fields: [profileId], references: [id], onDelete: Cascade)

  @@unique([commentId, profileId])
  @@index([commentId])
  @@index([userId])
  @@index([profileId])
  @@map("feed_post_comment_likes")
}

model FeedPostBookmark {
  id        String            @id @default(cuid())
  postId    String
  userId    String
  profileId String            // Which profile bookmarked this post
  createdAt DateTime          @default(now())
  post      FeedPost          @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  profile   InstagramProfile  @relation("ProfileBookmarks", fields: [profileId], references: [id], onDelete: Cascade)

  @@unique([postId, profileId])
  @@index([postId])
  @@index([userId])
  @@index([profileId])
  @@map("feed_post_bookmarks")
}

model MarketplaceModel {
  id          String              @id @default(cuid())
  name        String
  price       Float
  status      MarketplaceStatus   @default(AVAILABLE)
  imageUrl    String
  category    String              @default("Premium")
  gallery     String[]            @default([])
  description String              @db.Text
  included    String[]            @default([])
  usedFor     String[]            @default([])
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  @@index([status])
  @@index([createdAt])
  @@map("marketplace_models")
}

enum MarketplaceStatus {
  AVAILABLE
  SOLD
  RESERVED
}

// Weekly content planning for Instagram
model WeeklyPlanningSlot {
  id              String           @id @default(cuid())
  clerkId         String
  profileId       String?          // Link to InstagramProfile
  date            DateTime         // The day this slot belongs to
  slotType        WeeklySlotType   // REEL_1, REEL_2, STORY_BATCH, FEED_POST
  slotIndex       Int              @default(0) // For ordering slots of the same type
  status          WeeklySlotStatus @default(PLANNING)
  linkedPostId    String?          // Link to InstagramPost if assigned
  notes           String?          @db.Text // Notes, ideas, trending audio
  hashtags        String[]         @default([]) // Suggested hashtags
  trendingAudio   String?          // Trending audio/music suggestions
  contentIdeas    String?          @db.Text // Content ideas for this slot
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  linkedPost      InstagramPost?   @relation(fields: [linkedPostId], references: [id], onDelete: SetNull)

  @@unique([clerkId, date, slotType, slotIndex])
  @@index([clerkId])
  @@index([profileId])
  @@index([date])
  @@index([clerkId, date])
  @@index([linkedPostId])
  @@map("weekly_planning_slots")
}

enum WeeklySlotType {
  REEL_1          // First reel slot
  REEL_2          // Second reel slot
  STORY_BATCH     // Story batch slot
  FEED_POST       // Feed post slot
}

enum WeeklySlotStatus {
  PLANNING        // Just an idea/plan
  IN_PROGRESS     // Content being created
  READY           // Content ready to be assigned
  ASSIGNED        // Post assigned to this slot
  POSTED          // Successfully posted
}

// Content Pipeline for tracking all content across workflow stages
model ContentPipelineItem {
  id              String                @id @default(cuid())
  clerkId         String
  contentId       String                @unique // Unique identifier for tracking (e.g., "REEL-2025-001")
  title           String                // Content title/description
  contentType     ContentType           // REEL, POST, STORY, etc.
  status          PipelineStatus        @default(IDEA)
  linkedPostId    String?               // Link to InstagramPost if scheduled
  notes           String?               @db.Text
  dateCreated     DateTime?             // When content was created
  datePosted      DateTime?             // When content was posted
  // Stage timestamps
  ideaDate        DateTime?
  filmingDate     DateTime?
  editingDate     DateTime?
  reviewDate      DateTime?
  approvedDate    DateTime?
  scheduledDate   DateTime?
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt
  linkedPost      InstagramPost?        @relation(fields: [linkedPostId], references: [id], onDelete: SetNull)
  storySlot       StoryPlanningSlot?    // Link back to story slot if this is a story content
  reelSlot        ReelPlanningSlot?     @relation("ReelPipeline") // Link back to reel slot if this is a reel content
  feedPostSlot    FeedPostPlanningSlot? @relation("FeedPostPipeline") // Link back to feed post slot if this is a feed post content

  @@index([clerkId])
  @@index([status])
  @@index([clerkId, status])
  @@index([contentType])
  @@index([linkedPostId])
  @@map("content_pipeline_items")
}

enum ContentType {
  REEL
  POST
  STORY
  CAROUSEL
  VIDEO
}

enum PipelineStatus {
  IDEA          // Initial idea stage
  FILMING       // Currently filming
  EDITING       // In editing
  REVIEW        // Under review
  APPROVED      // Approved for scheduling
  SCHEDULED     // Scheduled for posting
  POSTED        // Successfully posted
  ARCHIVED      // Archived/not used
}



// Story Planning for Instagram Stories with time slots
model StoryPlanningSlot {
  id                String              @id @default(cuid())
  clerkId           String
  profileId         String?             // Link to InstagramProfile
  contentId         String?             @unique // Unique content ID for pipeline tracking (e.g., "STORY-2025-001")
  pipelineItemId    String?             @unique // Link to ContentPipelineItem
  date              DateTime            // The day this slot belongs to
  timeSlot          DateTime?           // Actual time for this story slot
  storyType         StoryType           // SELFIE, BEHIND_SCENES, PROMO, etc.
  interactiveElement InteractiveElement? // POLL, SLIDER, QUESTION, etc.
  linkedPostId      String?             // Link to InstagramPost if created
  // Direct file storage for story content (independent of Instagram staging)
  awsS3Key          String?             // S3 object key for uploaded content
  awsS3Url          String?             // Direct S3 URL for uploaded content
  fileName          String?             // Original filename
  mimeType          String?             // File MIME type
  notes             String?             @db.Text
  caption           String?             @db.Text
  hashtags          String[]            @default([])
  isPosted          Boolean             @default(false)
  postedAt          DateTime?
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  linkedPost        InstagramPost?      @relation("StorySlots", fields: [linkedPostId], references: [id], onDelete: SetNull)
  pipelineItem      ContentPipelineItem? @relation(fields: [pipelineItemId], references: [id], onDelete: SetNull)

  @@unique([clerkId, profileId, timeSlot])
  @@index([clerkId])
  @@index([profileId])
  @@index([date])
  @@index([clerkId, date])
  @@index([linkedPostId])
  @@index([pipelineItemId])
  @@index([contentId])
  @@map("story_planning_slots")
}

enum StoryTimeSlot {
  SLOT_9AM    // 9:00 AM
  SLOT_11AM   // 11:00 AM
  SLOT_1PM    // 1:00 PM
  SLOT_3PM    // 3:00 PM
  SLOT_5PM    // 5:00 PM
  SLOT_7PM    // 7:00 PM
  SLOT_9PM    // 9:00 PM
  SLOT_OTHER  // Custom time
}

enum StoryType {
  SELFIE              // Personal selfie
  BEHIND_SCENES       // Behind the scenes content
  PROMO               // Promotional content
  PRODUCT             // Product showcase
  GRWM                // Get Ready With Me
  OOTD                // Outfit of the Day
  QA                  // Q&A session
  TUTORIAL            // Tutorial/How-to
  LIFESTYLE           // Daily lifestyle
  ANNOUNCEMENT        // Announcements
  USER_CONTENT        // User-generated content
  OTHER               // Other types
}

enum InteractiveElement {
  POLL                // Yes/No or multiple choice poll
  SLIDER              // Emoji slider
  QUESTION            // Question sticker
  QUIZ                // Quiz sticker
  COUNTDOWN           // Countdown sticker
  LINK                // Link sticker
  MENTION             // @mention
  HASHTAG             // #hashtag
  LOCATION            // Location tag
  MUSIC               // Music sticker
  NONE                // No interactive element
}

// Reel Planning for Instagram Reels with time slots
model ReelPlanningSlot {
  id                String              @id @default(cuid())
  clerkId           String
  profileId         String?             // Link to InstagramProfile
  contentId         String?             @unique // Unique content ID for pipeline tracking (e.g., "REEL-2025-001")
  pipelineItemId    String?             @unique // Link to ContentPipelineItem
  date              DateTime            // The day this slot belongs to
  timeSlot          DateTime?           // Actual time for this reel slot
  reelType          ReelType            // TRENDING, TUTORIAL, BEHIND_SCENES, etc.
  hookIdea          String?             @db.Text // Hook/opening idea
  trendingAudio     String?             // Trending audio/song name
  // Direct file storage for reel content
  awsS3Key          String?             // S3 object key for uploaded content
  awsS3Url          String?             // Direct S3 URL for uploaded content
  fileName          String?             // Original filename
  mimeType          String?             // File MIME type
  notes             String?             @db.Text
  caption           String?             @db.Text
  hashtags          String[]            @default([])
  isPosted          Boolean             @default(false)
  postedAt          DateTime?
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  pipelineItem      ContentPipelineItem? @relation("ReelPipeline", fields: [pipelineItemId], references: [id], onDelete: SetNull)

  @@unique([clerkId, profileId, timeSlot])
  @@index([clerkId])
  @@index([profileId])
  @@index([date])
  @@index([clerkId, date])
  @@index([pipelineItemId])
  @@index([contentId])
  @@map("reel_planning_slots")
}

enum ReelType {
  TRENDING            // Trending content
  TUTORIAL            // Tutorial/How-to
  BEHIND_SCENES       // Behind the scenes
  PROMO               // Promotional content
  PRODUCT             // Product showcase
  LIFESTYLE           // Lifestyle content
  TRANSITION          // Transition reel
  DAY_IN_LIFE         // Day in the life
  CHALLENGE           // Challenge video
  COMEDY              // Comedy/funny content
  EDUCATIONAL         // Educational content
  OTHER               // Other types
}

// Feed Post Planning for Instagram Feed Posts
model FeedPostPlanningSlot {
  id                String              @id @default(cuid())
  clerkId           String
  profileId         String?             // Link to InstagramProfile
  contentId         String?             @unique // Unique content ID for pipeline tracking
  pipelineItemId    String?             @unique // Link to ContentPipelineItem
  date              DateTime            // The day this slot belongs to
  timeSlot          DateTime?           // Scheduled time for this feed post
  postType          FeedPostType        // SINGLE_IMAGE, CAROUSEL, etc.
  caption           String?             @db.Text
  hashtags          String[]            @default([])
  location          String?             // Location tag
  collaborators     String[]            @default([]) // Tagged accounts
  notes             String?             @db.Text
  // File storage for feed post content (supports multiple files for carousels/albums)
  files             Json?               // Array of {awsS3Key, awsS3Url, fileName, mimeType}
  isPosted          Boolean             @default(false)
  postedAt          DateTime?
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  pipelineItem      ContentPipelineItem? @relation("FeedPostPipeline", fields: [pipelineItemId], references: [id], onDelete: SetNull)

  @@unique([clerkId, profileId, timeSlot])
  @@index([clerkId])
  @@index([profileId])
  @@index([date])
  @@index([clerkId, date])
  @@index([pipelineItemId])
  @@index([contentId])
  @@map("feed_post_planning_slots")
}

enum FeedPostType {
  SINGLE_IMAGE        // Single image post
  CAROUSEL            // Multiple images/videos carousel
  VIDEO               // Single video post
  ALBUM               // Photo album
}

// Performance Metrics Model
model PerformanceMetric {
  id                String    @id @default(cuid())
  clerkId           String
  profileId         String    @default("") // Default to empty string for single profile tracking
  date              DateTime  @db.Date
  
  // Content metrics
  reelsPosted       Int       @default(0)
  storiesPosted     Int       @default(0)
  feedPostsPosted   Int       @default(0)
  
  // Engagement metrics
  totalViews        Int       @default(0)
  totalLikes        Int       @default(0)
  totalComments     Int       @default(0)
  totalShares       Int       @default(0)
  totalSaves        Int       @default(0)
  
  // Story metrics
  storyViews        Int       @default(0)
  storyReplies      Int       @default(0)
  
  // Follower metrics
  followersStart    Int       @default(0)
  followersEnd      Int       @default(0)
  followersGained   Int       @default(0)
  followersLost     Int       @default(0)
  
  // Calculated metrics (can be computed)
  engagementRate    Float?    // (likes + comments + shares) / reach * 100
  averageViews      Float?    // total views / content posted
  
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@unique([clerkId, date, profileId])
  @@index([clerkId, date])
  @@map("performance_metrics")
}

// Workflow Checklist - User customizable workflow phases
model WorkflowPhase {
  id          String              @id @default(cuid())
  clerkId     String
  profileId   String              @default("") // Default to empty string for single profile tracking
  name        String
  description String?             @db.Text
  icon        String              @default("Circle") // Icon name as string
  color       String              @default("blue")
  order       Int                 // Order of phases
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  items       WorkflowCheckItem[]

  @@index([clerkId])
  @@index([clerkId, profileId])
  @@index([clerkId, order])
  @@map("workflow_phases")
}

// Workflow Checklist Items
model WorkflowCheckItem {
  id          String        @id @default(cuid())
  phaseId     String
  text        String        @db.Text
  order       Int           // Order within the phase
  checked     Boolean       @default(false)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  phase       WorkflowPhase @relation(fields: [phaseId], references: [id], onDelete: Cascade)

  @@index([phaseId])
  @@index([phaseId, order])
  @@map("workflow_check_items")
}

// Hashtag Bank - User customizable hashtag sets
model HashtagSet {
  id          String   @id @default(cuid())
  clerkId     String
  name        String
  category    String
  description String?  @db.Text
  icon        String   @default("Hash") // Icon name as string
  color       String   @default("blue")
  hashtags    String[] // Array of hashtag strings
  order       Int      // Order of hashtag sets
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([clerkId])
  @@index([clerkId, order])
  @@map("hashtag_sets")
}

// Vault Folder - Organize vault media by profile
model VaultFolder {
  id        String      @id @default(cuid())
  clerkId   String
  profileId String      // Instagram profile this folder belongs to
  name      String      // Folder name
  isDefault Boolean     @default(false) // Default "All Media" folder
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  items     VaultItem[] // Items in this folder

  @@index([clerkId])
  @@index([profileId])
  @@index([clerkId, profileId])
  @@map("vault_folders")
}

// Vault Item - Media files stored in vault
model VaultItem {
  id        String      @id @default(cuid())
  clerkId   String
  profileId String      // Instagram profile this item belongs to
  folderId  String      // Folder containing this item
  fileName  String      // Original file name
  fileType  String      // MIME type (image/*, video/*, audio/*)
  fileSize  Int         // File size in bytes
  awsS3Key  String      // S3 object key: vault/{clerkId}/{profileId}/{folderId}/{fileName}
  awsS3Url  String      // Direct S3 URL
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  folder    VaultFolder @relation(fields: [folderId], references: [id], onDelete: Cascade)

  @@index([clerkId])
  @@index([profileId])
  @@index([folderId])
  @@index([clerkId, profileId, folderId])
  @@index([awsS3Key])
  @@map("vault_items")
}

// Caption Bank - Store captions organized by Instagram profile
model Caption {
  id              String           @id @default(cuid())
  clerkId         String
  profileId       String           // Link to InstagramProfile
  caption         String           @db.Text
  captionCategory String           // e.g., "Inspirational", "Artistic", "Process"
  captionTypes    String           // e.g., "Motivational", "Storytelling"
  captionBanks    String           // e.g., "General Collection", "Art & Design"
  usageCount      Int              @default(0)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  profile         InstagramProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@index([clerkId])
  @@index([profileId])
  @@index([clerkId, profileId])
  @@map("captions")
}
